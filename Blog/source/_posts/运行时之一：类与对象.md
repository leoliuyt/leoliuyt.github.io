---
title: 运行时之一：类与对象
date: 2018-04-04 15:30:53
tags: runtime
categories: Objective-C
---

Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。

这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即`Objc Runtime`。`Objc Runtime`其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。

`Objc runtime`是开源的，我已fork了一份用于添加注释和学习，点击[objc runtime 723](https://github.com/leoliuyt/objc-runtime)。在本文中，我们将对照源码，先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。

## 类与对象数据结构

### Class

Objective-C类是由`Class`类型表示的，它实际上是一个指定`objc_class`结构体的指针。它的定义如下：

```objc
typedef struct objc_class *Class;
```

查看`objc/runtime.h`中的`objc_class`结构体的定义如下：

```objc
struct objc_class {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;

```
在这个定义中，面几个字段是我们感兴趣的：
1. `isa`: 需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的`Class里面也有一个`isa`指针，它指向`metaClass`（元类）。
2. `super_class`: 指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。
3. `name`: 类名
4. `version`: 我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。
5. `ivars`: 成员变量列表
6. `methodLists`: 方法列表
7. `protocols`: 遵循的协议列表
8. `cache`: 用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。

针对`cache`,我们用下面例子来说明其执行过程
```
NSArray *array = [NSArray alloc] init];
```
其流程是：
1. `[NSArray alloc]`先被执行。因为NSArray没有`+alloc`方法，于是去父类NSObject去查找。
2. 检测NSObject是否响应`+alloc`方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把`isa`指针指向NSArray类。同时，`+alloc`也被加进cache列表里面。
3. 接着，执行`-init`方法，如果NSArray响应该方法，则直接将其加入`cache`；如果不响应，则去父类查找。
4. 在后期的操作中，如果再以`[[NSArray alloc] init]`这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。

### Meta-Class（元类）

`metaclass`是一个类对象的类，所有的`metaclass`的`isa`指针指向的是根元类。 而根元类的`isa`指针指向自己，形成一个闭环。在`NSObject`继承体系下的`metaclass`都使用`NSObject`的`metaclass`作为根元类。

通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应`metaclass`类的一个继承体系了，如下图所示：
{% asset_img class-metaClass.png 对象、类、元类关系图 %}

当我们向一个对象发送消息时，runtime会在这个对象所属的类的方法列表中查找方法；而向一个类方法发送消息时，会在这个类的`metaclass`的方法列表中查找。

对于`NSObject`继承体系来说，其实例方法对体系中的所有实例对象、类和`metaclass`都是有效的；而类方法对于体系内的所有类和`metaclass`都是有效的。

> 注意：
> 类方法存储在metaclass中

获取类的某一实例的所有的实例方法列表:

```objc
- (void)methodListAction {
    unsigned int count;
    Method *mothodList = class_copyMethodList([self.ps class], &count);
    NSMutableString *str = [NSMutableString stringWithString:@""];
    for (unsigned int i = 0; i < count; i++) {
        Method method = mothodList[i];
        SEL sel = method_getName(method);
        [str appendFormat:@"%@\n",NSStringFromSelector(sel)];
    }
    self.textView.text = [str copy];
}
```

获取类的所有类方法列表：

```objc
- (void)classMethodListAction {
    NSString *clsStr = NSStringFromClass(self.father.class);
    Class metaClass = objc_getMetaClass(clsStr.UTF8String);
//    Class metaClass = object_getClass([self.ps class]);
    NSLog(@"%@",NSStringFromClass(metaClass));
    if (class_isMetaClass(metaClass)) {
        unsigned int count;
        Method *mothodList = class_copyMethodList(metaClass, &count);
        NSMutableString *str = [NSMutableString stringWithString:@""];
        for (unsigned int i = 0; i < count; i++) {
            Method method = mothodList[i];
            SEL sel = method_getName(method);
            [str appendFormat:@"%@\n",NSStringFromSelector(sel)];
        }
        self.textView.text = [str copy];
    }
}
```

### objc_object与id

`objc_object`是表示一个类的实例的结构体，它的定义如下(`objc/objc.h`)：

```objc
struct objc_object {
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
};

typedef struct objc_object *id;
```
可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的`isa`指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。

当创建一个特定类的实例对象时，分配的内存包含一个`objc_object`数据结构，然后是类的实例变量的数据。`NSObject`类的`alloc`和`allocWithZone:`方法使用函数`class_createInstance`来创建`objc_object`数据结构。

另外还有我们常见的`id`，它是一个`objc_object`结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中`void *`指针类型的作用。

## 类与对象的操作函数
runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class_为前缀的，而对象的操作方法大部分是以objc_或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。

### 类相关操作函数

我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。

#### 类名(name)

类名操作的函数主要有：

```objc
const char * class_getName(Class cls); 
```

#### 父类(super_class)和元类(meta-class)
父类和元类操作的函数主要有：

```objc
// 获取类的父类
Class class_getSuperclass ( Class cls );
// 判断给定的Class是否是一个元类
BOOL class_isMetaClass ( Class cls );
```
`class_getSuperclass`函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。

`class_isMetaClass`函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。

#### 实例变量大小(instance_size)

实例变量大小操作的函数有：

```
// 获取实例大小
size_t class_getInstanceSize ( Class cls );
```
#### 成员变量(ivars)及属性

在`objc_class`中，所有的成员变量、属性的信息是放在链表`ivars`中的。`ivars`是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：

1.成员变量操作函数，主要包含以下函数：

```objc
// 获取类中指定名称实例成员变量的信息
Ivar class_getInstanceVariable ( Class cls, const char *name );
// 获取类成员变量的信息
Ivar class_getClassVariable ( Class cls, const char *name );
// 添加成员变量
BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );
// 获取整个成员变量列表
Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );
```
`class_getInstanceVariable`函数，它返回一个指向包含name指定的成员变量信息的`objc_ivar`结构体的指针(Ivar)。

`class_getClassVariable`函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。

Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用`class_addIvar`函数了。不过需要注意的是，这个方法只能在`objc_allocateClassPair`函数与`objc_registerClassPair`之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是`1<<alignment`。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递`log2(sizeof(pointer_type))`。

`class_copyIvarList`函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的`objc_ivar`结构体的指针。这个数组不包含在父类中声明的变量。`outCount`指针返回数组的大小。需要注意的是，我们必须使用`free()`来释放这个数组。

2.属性操作函数，主要包含以下函数：

```objc
// 获取指定的属性
objc_property_t class_getProperty ( Class cls, const char *name );
// 获取属性列表
objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );
// 为类添加属性
BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
// 替换类的属性
void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );
```
这一种方法也是针对ivars来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。

3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：

```objc
const uint8_t * class_getIvarLayout ( Class cls );
void class_setIvarLayout ( Class cls, const uint8_t *layout );
const uint8_t * class_getWeakIvarLayout ( Class cls );
void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );

```
但通常情况下，我们不需要去主动调用这些方法；在调用`objc_registerClassPair`时，会生成合理的布局。在此不详细介绍这些函数。

#### 方法(methodLists)

方法操作主要有以下函数：

```objc
// 添加方法
BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );
// 获取实例方法
Method class_getInstanceMethod ( Class cls, SEL name );
// 获取类方法
Method class_getClassMethod ( Class cls, SEL name );
// 获取所有方法的数组
Method * class_copyMethodList ( Class cls, unsigned int *outCount );
// 替代方法的实现
IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );
// 返回方法的具体实现
IMP class_getMethodImplementation ( Class cls, SEL name );
IMP class_getMethodImplementation_stret ( Class cls, SEL name );
// 类实例是否响应指定的selector
BOOL class_respondsToSelector ( Class cls, SEL sel );
```
class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数–self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：

```objc
void myMethodIMP(id self, SEL _cmd)
{
    // implementation ....
}
```
与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。

另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。

`class_getInstanceMethod`、`class_getClassMethod`函数，与`class_copyMethodList`不同的是，这两个函数都会去搜索父类的实现。

`class_copyMethodList`函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用`class_copyMethodList(object_getClass(cls), &count)`(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。

`class_replaceMethod`函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于`class_addMethod`函数一样会添加方法；如果类中已存在name指定的方法，则类似于`method_setImplementation`一样替代原方法的实现。

`class_getMethodImplementation`函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比`method_getImplementation(class_getInstanceMethod(cls, name))`更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。

`class_respondsToSelector`函数，我们通常使用NSObject类的`respondsToSelector:`或`instancesRespondToSelector:`方法来达到相同目的。
#### 协议(objc_protocol_list)

协议相关的操作包含以下函数：
```objc
// 添加协议
BOOL class_addProtocol ( Class cls, Protocol *protocol );
// 返回类是否实现指定的协议
BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );
// 返回类实现的协议列表
Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );

```
`class_conformsToProtocol`函数可以使用NSObject类的`conformsToProtocol:`方法来替代。

`class_copyProtocolList`函数返回的是一个数组，在使用后我们需要使用`free()`手动释放。
#### 版本(version)

版本相关的操作包含以下函数：
```objc
// 获取版本号
int class_getVersion ( Class cls );
// 设置版本号
void class_setVersion ( Class cls, int version );
```
#### 其它
runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：
```objc
Class objc_getFutureClass ( const char *name );
void objc_setFutureClass ( Class cls, const char *name );
```
通常我们不直接使用这两个函数。

### 动态穿件类和对象
### 实例操作函数
### 获取类定义
## 小结

## QA

1、用分类给NSObject添加一个实例方法（例如`- (void)dm_instanceMethod`），用类调用的方式调用该方法(`[NSObject dm_instanceMethod]`)会发生什么？
答案：正常调用

回答要点：
1、类即对象
2、NSObject的isa指向metaClass，即NSObject是metaClass的实例，即NSObject 是一个类对象
3、metaClass继承自NSObject

NSObject类对象 调用了从NSObject继承下来的dm_instanceMethod方法

> 结论：
> 对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。

验证代码如下：

```objc
@implementation NSObject (DM)

- (void)dm_instanceMethod
{
    NSLog(@"%s",__func__);
}
@end

@interface Father : NSObject

- (NSString *)getSex;

@end
```
可以通过`[NSObject dm_instanceMethod]`调用，也可以通过其子类`[Father dm_instanceMethod]`调用
而Father中的方法只能通过Father的实例来调用`[[Father new] getSex]`,不可以通过`[Father getSex]`调用。

## 参考
[Objective-C Runtime 运行时之一：类与对象](http://southpeak.github.io/2014/10/25/objective-c-runtime-1/)
[Objective-C Runtime Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048)
[Objective-C Runtime](https://developer.apple.com/documentation/objectivec/objective_c_runtime)