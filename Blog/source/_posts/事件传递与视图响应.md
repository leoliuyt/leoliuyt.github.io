---
title: 事件传递与响应者链条
date: 2018-05-25 18:00:59
tags: [UI,iOS]
categories: Cocoa Touch
---

点击了屏幕上的一个View，事件是怎么找到这个View的呢？这个View又是怎么响应这个传递过来的事件的呢？

## 事件传递

当点击了屏幕上的一个View后，系统会产生一个`UIEvent`事件，这个事件被加入到由`UIApplication`管理的一个事件队列中，`UIApplication`会从事件队列中取出最前面的事件,然后再传递给`UIWindow`,最后`UIWindow`通过`- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; `和
`- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;`在视图层次结构中找到一个最合适的view来处理触摸事件。

{% asset_img event_transmit.png 事件传递 %}


如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件

view 不能处理触摸事件的情况：
1. userInteractionEnabled = NO
2. hidden = YES
3. alpha = 0.0~0.01（临界点待确定）

### 查找最合适的view来处理事件

1.自己是否能接收触摸事件？否事件传递结束
2.触摸点是否在自己身上？否事件传递结束
3.从后往前遍历子控件，重复前面的两步
4.如果没有符合条件的子控件，那么就自己最合适处理

```
//调用时机：只要有一个事件传递到控件上，就会调用控件的这个方法。point是基于方法调用者的坐标系
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

//用来判断point这个点是否在方法调用者上，point基于方法调用者的坐标系
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;
```

模拟系统，实现hitTest方法

```Objective-C
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event
{
    if(self.hidden == YES || self.alpha <= 0.01 || self.userInteractionEnabled == NO){
        return nil;
    }

    if([self pointInside:point withEvent:event] == NO){
        return nil;
    }

    int count = self.subviews.count;
    for(int i = count-1; i >= 0; i--){
        UIView *childView = self.subviews[i];
        CGPoint childP = [self convertPoint:point toView:childView];
        UIView *bestView = [childView hitTest:childP withEvent:event];
        if(bestView){
            return bestView;
        }
    }
    return self;
}
```

当一个View的超出了它的父视图，点击时，是无法接受事件的，如果想让它接收事件，可以通过下面方式实现

{% asset_img event_example 实例1 %}

代码实现如下

```Objective-C
//BottomView.m中

//方式一：
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
    CGPoint scantPoint = [self convertPoint:point toView:self.scanBtn];
    if ([self.scanBtn pointInside:scantPoint withEvent:event]) {
        return self.scanBtn;
    } else {
        return [super hitTest:point withEvent:event];
    }
}

//方式二：
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
{
    CGPoint scantPoint = [self convertPoint:point toView:self.scanBtn];
    if ([self.scanBtn pointInside:scantPoint withEvent:event]) {
        return YES;
    }
    return [super pointInside:point withEvent:event];
}
```
[Demo](https://github.com/leoliuyt/DMEventDeliver)