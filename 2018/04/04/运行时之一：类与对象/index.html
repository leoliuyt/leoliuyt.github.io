<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="runtime," />










<meta name="description" content="Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。 这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正">
<meta name="keywords" content="runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="运行时之一：类与对象">
<meta property="og:url" content="http://leoliuyt.github.io/2018/04/04/运行时之一：类与对象/index.html">
<meta property="og:site_name" content="Leoliu">
<meta property="og:description" content="Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。 这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://leoliuyt.github.io/2018/04/04/运行时之一：类与对象/class-metaClass.png">
<meta property="og:updated_time" content="2018-05-25T10:38:41.748Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="运行时之一：类与对象">
<meta name="twitter:description" content="Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。 这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正">
<meta name="twitter:image" content="http://leoliuyt.github.io/2018/04/04/运行时之一：类与对象/class-metaClass.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://leoliuyt.github.io/2018/04/04/运行时之一：类与对象/"/>





  <title>运行时之一：类与对象 | Leoliu</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?39278431666862f9e43bc023abb6c81b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leoliu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-objective-c">
          <a href="/categories/Objective-C/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Objective-C
          </a>
        </li>
      
        
        <li class="menu-item menu-item-shell">
          <a href="/categories/shell/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-taxi"></i> <br />
            
            shell
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tool">
          <a href="/categories/tool/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-wrench"></i> <br />
            
            工具
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa-touch">
          <a href="/categories/Cocoa-Touch/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br />
            
            Cocoa Touch
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/categories/Cocoa/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-apple"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-python">
          <a href="/categories/Python/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bar-chart"></i> <br />
            
            Python
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://leoliuyt.github.io/2018/04/04/运行时之一：类与对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leoliu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leoliu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">运行时之一：类与对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T15:30:53+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即<code>Objc Runtime</code>。<code>Objc Runtime</code>其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p><code>Objc runtime</code>是开源的，我已fork了一份用于添加注释和学习，点击<a href="https://github.com/leoliuyt/objc-runtime" target="_blank" rel="noopener">objc runtime 723</a>。在本文中，我们将对照源码，先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>
<h2 id="类与对象数据结构"><a href="#类与对象数据结构" class="headerlink" title="类与对象数据结构"></a>类与对象数据结构</h2><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>Objective-C类是由<code>Class</code>类型表示的，它实际上是一个指定<code>objc_class</code>结构体的指针。它的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>查看<code>objc/runtime.h</code>中的<code>objc_class</code>结构体的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">long</span> instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>在这个定义中，面几个字段是我们感兴趣的：</p>
<ol>
<li><code>isa</code>: 需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的<code>Class里面也有一个</code>isa<code>指针，它指向</code>metaClass`（元类）。</li>
<li><code>super_class</code>: 指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。</li>
<li><code>name</code>: 类名</li>
<li><code>version</code>: 我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
<li><code>ivars</code>: 成员变量列表</li>
<li><code>methodLists</code>: 方法列表</li>
<li><code>protocols</code>: 遵循的协议列表</li>
<li><code>cache</code>: 用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</li>
</ol>
<p>针对<code>cache</code>,我们用下面例子来说明其执行过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = [NSArray alloc] init];</span><br></pre></td></tr></table></figure></p>
<p>其流程是：</p>
<ol>
<li><code>[NSArray alloc]</code>先被执行。因为NSArray没有<code>+alloc</code>方法，于是去父类NSObject去查找。</li>
<li>检测NSObject是否响应<code>+alloc</code>方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把<code>isa</code>指针指向NSArray类。同时，<code>+alloc</code>也被加进cache列表里面。</li>
<li>接着，执行<code>-init</code>方法，如果NSArray响应该方法，则直接将其加入<code>cache</code>；如果不响应，则去父类查找。</li>
<li>在后期的操作中，如果再以<code>[[NSArray alloc] init]</code>这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。</li>
</ol>
<h3 id="Meta-Class（元类）"><a href="#Meta-Class（元类）" class="headerlink" title="Meta-Class（元类）"></a>Meta-Class（元类）</h3><p><code>metaclass</code>是一个类对象的类，所有的<code>metaclass</code>的<code>isa</code>指针指向的是根元类。 而根元类的<code>isa</code>指针指向自己，形成一个闭环。在<code>NSObject</code>继承体系下的<code>metaclass</code>都使用<code>NSObject</code>的<code>metaclass</code>作为根元类。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应<code>metaclass</code>类的一个继承体系了，如下图所示：<br><img src="/2018/04/04/运行时之一：类与对象/class-metaClass.png" title="对象、类、元类关系图"></p>
<p>当我们向一个对象发送消息时，runtime会在这个对象所属的类的方法列表中查找方法；而向一个类方法发送消息时，会在这个类的<code>metaclass</code>的方法列表中查找。</p>
<p>对于<code>NSObject</code>继承体系来说，其实例方法对体系中的所有实例对象、类和<code>metaclass</code>都是有效的；而类方法对于体系内的所有类和<code>metaclass</code>都是有效的。</p>
<blockquote>
<p>注意：<br>类方法存储在metaclass中</p>
</blockquote>
<p>获取类的某一实例的所有的实例方法列表:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)methodListAction &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    Method *mothodList = class_copyMethodList([<span class="keyword">self</span>.ps <span class="keyword">class</span>], &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@""</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = mothodList[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        [str appendFormat:<span class="string">@"%@\n"</span>,<span class="built_in">NSStringFromSelector</span>(sel)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.textView.text = [str <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取类的所有类方法列表：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)classMethodListAction &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *clsStr = <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.father.class);</span><br><span class="line">    Class metaClass = objc_getMetaClass(clsStr.UTF8String);</span><br><span class="line"><span class="comment">//    Class metaClass = object_getClass([self.ps class]);</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromClass</span>(metaClass));</span><br><span class="line">    <span class="keyword">if</span> (class_isMetaClass(metaClass)) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">        Method *mothodList = class_copyMethodList(metaClass, &amp;count);</span><br><span class="line">        <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@""</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Method method = mothodList[i];</span><br><span class="line">            SEL sel = method_getName(method);</span><br><span class="line">            [str appendFormat:<span class="string">@"%@\n"</span>,<span class="built_in">NSStringFromSelector</span>(sel)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.textView.text = [str <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="objc-object与id"><a href="#objc-object与id" class="headerlink" title="objc_object与id"></a>objc_object与id</h3><p><code>objc_object</code>是表示一个类的实例的结构体，它的定义如下(<code>objc/objc.h</code>)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的<code>isa</code>指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个<code>objc_object</code>数据结构，然后是类的实例变量的数据。<code>NSObject</code>类的<code>alloc</code>和<code>allocWithZone:</code>方法使用函数<code>class_createInstance</code>来创建<code>objc_object</code>数据结构。</p>
<p>另外还有我们常见的<code>id</code>，它是一个<code>objc_object</code>结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中<code>void *</code>指针类型的作用。</p>
<h2 id="类与对象的操作函数"><a href="#类与对象的操作函数" class="headerlink" title="类与对象的操作函数"></a>类与对象的操作函数</h2><p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class_为前缀的，而对象的操作方法大部分是以objc_或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<h3 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h3><p>我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<h4 id="类名-name"><a href="#类名-name" class="headerlink" title="类名(name)"></a>类名(name)</h4><p>类名操作的函数主要有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName(Class cls);</span><br></pre></td></tr></table></figure>
<h4 id="父类-super-class-和元类-meta-class"><a href="#父类-super-class-和元类-meta-class" class="headerlink" title="父类(super_class)和元类(meta-class)"></a>父类(super_class)和元类(meta-class)</h4><p>父类和元类操作的函数主要有：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line">Class class_getSuperclass ( Class cls );</span><br><span class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</span><br></pre></td></tr></table></figure>
<p><code>class_getSuperclass</code>函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</p>
<p><code>class_isMetaClass</code>函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</p>
<h4 id="实例变量大小-instance-size"><a href="#实例变量大小-instance-size" class="headerlink" title="实例变量大小(instance_size)"></a>实例变量大小(instance_size)</h4><p>实例变量大小操作的函数有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取实例大小</span><br><span class="line">size_t class_getInstanceSize ( Class cls );</span><br></pre></td></tr></table></figure>
<h4 id="成员变量-ivars-及属性"><a href="#成员变量-ivars-及属性" class="headerlink" title="成员变量(ivars)及属性"></a>成员变量(ivars)及属性</h4><p>在<code>objc_class</code>中，所有的成员变量、属性的信息是放在链表<code>ivars</code>中的。<code>ivars</code>是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<p>1.成员变量操作函数，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure>
<p><code>class_getInstanceVariable</code>函数，它返回一个指向包含name指定的成员变量信息的<code>objc_ivar</code>结构体的指针(Ivar)。</p>
<p><code>class_getClassVariable</code>函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>
<p>Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用<code>class_addIvar</code>函数了。不过需要注意的是，这个方法只能在<code>objc_allocateClassPair</code>函数与<code>objc_registerClassPair</code>之间调用。另外，这个类也不能是元类。</p>
<p><code>class_copyIvarList</code>函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的<code>objc_ivar</code>结构体的指针。这个数组不包含在父类中声明的变量。<code>outCount</code>指针返回数组的大小。需要注意的是，我们必须使用<code>free()</code>来释放这个数组。</p>
<p>2.属性操作函数，主要包含以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br></pre></td></tr></table></figure>
<p>这一种方法也是针对ivars来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uint8_t * class_getIvarLayout ( Class cls );</span><br><span class="line"><span class="keyword">void</span> class_setIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</span><br><span class="line"><span class="keyword">const</span> uint8_t * class_getWeakIvarLayout ( Class cls );</span><br><span class="line"><span class="keyword">void</span> class_setWeakIvarLayout ( Class cls, <span class="keyword">const</span> uint8_t *layout );</span><br></pre></td></tr></table></figure>
<p>但通常情况下，我们不需要去主动调用这些方法；在调用<code>objc_registerClassPair</code>时，会生成合理的布局。在此不详细介绍这些函数。</p>
<h4 id="方法-methodLists"><a href="#方法-methodLists" class="headerlink" title="方法(methodLists)"></a>方法(methodLists)</h4><p>方法操作主要有以下函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line">Method class_getInstanceMethod ( Class cls, SEL name );</span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line">Method class_getClassMethod ( Class cls, SEL name );</span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"><span class="comment">// 返回方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</span><br></pre></td></tr></table></figure>
<p>class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数–self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。</p>
<p>另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
<p><code>class_getInstanceMethod</code>、<code>class_getClassMethod</code>函数，与<code>class_copyMethodList</code>不同的是，这两个函数都会去搜索父类的实现。</p>
<p><code>class_copyMethodList</code>函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用<code>class_copyMethodList(object_getClass(cls), &amp;count)</code>(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</p>
<p><code>class_replaceMethod</code>函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于<code>class_addMethod</code>函数一样会添加方法；如果类中已存在name指定的方法，则类似于<code>method_setImplementation</code>一样替代原方法的实现。</p>
<p><code>class_getMethodImplementation</code>函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比<code>method_getImplementation(class_getInstanceMethod(cls, name))</code>更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</p>
<p><code>class_respondsToSelector</code>函数，我们通常使用NSObject类的<code>respondsToSelector:</code>或<code>instancesRespondToSelector:</code>方法来达到相同目的。</p>
<h4 id="协议-objc-protocol-list"><a href="#协议-objc-protocol-list" class="headerlink" title="协议(objc_protocol_list)"></a>协议(objc_protocol_list)</h4><p>协议相关的操作包含以下函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure></p>
<p><code>class_conformsToProtocol</code>函数可以使用NSObject类的<code>conformsToProtocol:</code>方法来替代。</p>
<p><code>class_copyProtocolList</code>函数返回的是一个数组，在使用后我们需要使用<code>free()</code>手动释放。</p>
<h4 id="版本-version"><a href="#版本-version" class="headerlink" title="版本(version)"></a>版本(version)</h4><p>版本相关的操作包含以下函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</span><br></pre></td></tr></table></figure></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getFutureClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="keyword">void</span> objc_setFutureClass ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br></pre></td></tr></table></figure></p>
<p>通常我们不直接使用这两个函数。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)classAssociatedOption</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"类相关操作===========\n"</span>);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *str = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@""</span>];</span><br><span class="line">    <span class="comment">//获取类名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charName = class_getName(<span class="keyword">self</span>.ps.class);</span><br><span class="line">    <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithCString:charName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    [str appendFormat:<span class="string">@"获取类名:%@\n"</span>,name];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    <span class="comment">//获取父类</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *superCharName = class_getName(class_getSuperclass(<span class="keyword">self</span>.ps.class));</span><br><span class="line">    <span class="built_in">NSString</span> *superName = [<span class="built_in">NSString</span> stringWithCString:superCharName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"获取父类类名:%@"</span>,superName);</span><br><span class="line">    [str appendFormat:<span class="string">@"获取父类类名:%@\n"</span>,superName];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否是元类</span></span><br><span class="line">    <span class="built_in">BOOL</span> isMeta = class_isMetaClass(<span class="keyword">self</span>.ps.class);</span><br><span class="line">    [str appendFormat:<span class="string">@"%@是否是元类:%@\n"</span>,name,isMeta?<span class="string">@"是"</span>:<span class="string">@"否"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取元类（objc_方法)</span></span><br><span class="line">    Class metaClass = objc_getMetaClass(charName);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charMetaClassName = class_getName(metaClass);</span><br><span class="line">    <span class="built_in">NSString</span> *metaName = [<span class="built_in">NSString</span> stringWithCString:charMetaClassName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    [str appendFormat:<span class="string">@"%@的元类名:%@;是否是元类:%@\n"</span>,name,metaName,class_isMetaClass(metaClass)?<span class="string">@"是"</span>:<span class="string">@"否"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//变量实例大小</span></span><br><span class="line">    [str appendFormat:<span class="string">@"%@的变量实例大小:%zu\n"</span>,name,class_getInstanceSize(<span class="keyword">self</span>.ps.class)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取指定名称的实例</span></span><br><span class="line">    Ivar ivar = class_getInstanceVariable(<span class="keyword">self</span>.ps.class, <span class="string">"_name"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ivar != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        [str appendFormat:<span class="string">@"获取%@类中指定_name的实例:%s\n"</span>,name,ivar_getName(ivar)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    <span class="comment">// 协议</span></span><br><span class="line">    <span class="keyword">unsigned</span> outCount;</span><br><span class="line">    Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(<span class="keyword">self</span>.ps.class, &amp;outCount);</span><br><span class="line">    Protocol * protocol;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">        protocol = protocols[i];</span><br><span class="line">         [str appendFormat:<span class="string">@"获取%@类中遵循的协议名%s\n"</span>,name,protocol_getName(protocol)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">BOOL</span> isConforms = class_conformsToProtocol(<span class="keyword">self</span>.ps.class, protocol);</span><br><span class="line">    [str appendFormat:<span class="string">@"获取%@类是否遵循了%s协议:%@\n"</span>,name,protocol_getName(protocol),isConforms ? <span class="string">@"是"</span>:<span class="string">@"否"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"=================\n"</span>);</span><br><span class="line">    <span class="keyword">self</span>.textView.text = [str <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br></pre></td></tr></table></figure></p>
<p>获取类名:Person</p>
<p>获取父类类名:NSObject</p>
<p>Person是否是元类:否</p>
<p>Person的元类名:Person;是否是元类:是</p>
<p>Person的变量实例大小:48</p>
<p>获取Person类中指定_name的实例:_name</p>
<p>获取Person类中遵循的协议名NSCopying</p>
<p>获取Person类是否遵循了NSCopying协议:是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="动态创建类和对象"><a href="#动态创建类和对象" class="headerlink" title="动态创建类和对象"></a>动态创建类和对象</h3><p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<h4 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h4><p>动态创建类涉及到以下几个函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新类和元类</span></span><br><span class="line">Class objc_allocateClassPair ( Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes );</span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair ( Class cls );</span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair ( Class cls );</span><br></pre></td></tr></table></figure>
<p><code>objc_allocateClassPair</code>函数：如果我们要创建一个根类，则<code>superclass</code>指定为Nil。<code>extraBytes</code>通常指定为0，该参数是分配给类和元类对象尾部的索引<code>ivars</code>的字节数。<br>为了创建一个新类，我们需要调用<code>objc_allocateClassPair</code>。然后使用诸如<code>class_addMethod</code>，<code>class_addIvar</code>等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用<code>objc_registerClassPair</code>函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
<p><code>objc_disposeClassPair</code>函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。<br>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dynamicCreateClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个继承自self.ps的类SubClass</span></span><br><span class="line">    Class subClass = objc_allocateClassPair(<span class="keyword">self</span>.ps.class, <span class="string">"SubClass"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block 调用"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    IMP imp_subMethod = imp_implementationWithBlock(block);</span><br><span class="line">    <span class="comment">//向SubClass中添加方法</span></span><br><span class="line">    class_addMethod(subClass, <span class="keyword">@selector</span>(addMethod), imp_subMethod, <span class="string">"v@:"</span>);</span><br><span class="line">    <span class="comment">//添加实例变量</span></span><br><span class="line">    class_addIvar(subClass, <span class="string">"_ivar1"</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加属性</span></span><br><span class="line">    objc_property_attribute_t type = &#123;<span class="string">"T"</span>, <span class="string">"@\"NSString\""</span>&#125;;</span><br><span class="line">    objc_property_attribute_t ownership = &#123; <span class="string">"C"</span>, <span class="string">""</span> &#125;;</span><br><span class="line">    objc_property_attribute_t backingivar = &#123; <span class="string">"V"</span>, <span class="string">"_ivar1"</span>&#125;;</span><br><span class="line">    objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line">    class_addProperty(subClass, <span class="string">"property2"</span>, attrs, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    objc_registerClassPair(subClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建类的实例</span></span><br><span class="line">    <span class="keyword">id</span> instance = [[subClass alloc] init];</span><br><span class="line">    [instance performSelector:<span class="keyword">@selector</span>(addMethod)];</span><br><span class="line">    [instance setValue:<span class="string">@"hello world"</span> forKey:<span class="string">@"_ivar1"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"_ivar1======%@==="</span>,[instance valueForKey:<span class="string">@"_ivar1"</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h4><p>动态创建对象的函数如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例</span></span><br><span class="line"><span class="keyword">id</span> class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"><span class="comment">// 在指定位置创建类实例</span></span><br><span class="line"><span class="keyword">id</span> objc_constructInstance ( Class cls, <span class="keyword">void</span> *bytes );</span><br><span class="line"><span class="comment">// 销毁类实例</span></span><br><span class="line"><span class="keyword">void</span> * objc_destructInstance ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure></p>
<p><code>class_createInstance</code>函数：创建实例时，会在默认的内存区域为类分配内存。<code>extraBytes</code>参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。<br>调用<code>class_createInstance</code>的效果与<code>+alloc</code>方法类似。不过在使用<code>class_createInstance</code>时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用<code>NSString</code>来测试一下该函数的实际效果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dynamicInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@"test"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [str2 <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span></span><br><span class="line">__NSCFConstantString</span><br></pre></td></tr></table></figure>
<p>可以看到，使用<code>class_createInstance</code>函数获取的是<code>NSString</code>实例，而不是类簇中的默认占位符类<code>__NSCFConstantString</code>。</p>
<p><code>objc_constructInstance</code>函数：在指定的位置(bytes)创建类实例。</p>
<p><code>objc_destructInstance</code>函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
<h3 id="实例操作函数"><a href="#实例操作函数" class="headerlink" title="实例操作函数"></a>实例操作函数</h3><p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<p>1.针对整个对象进行操作的函数，这类函数包含<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br></pre></td></tr></table></figure></p>
<p>上面个两个方法在ARC模式下不可用</p>
<p>2.针对对象实例变量进行操作的函数，这类函数包含：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value ); <span class="comment">//ARC模式下不可用</span></span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );<span class="comment">//ARC模式下不可用</span></span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );<span class="comment">//ARC模式下不可用</span></span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br></pre></td></tr></table></figure></p>
<p>3.针对对象的类进行操作的函数，这类函数包含：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</span><br></pre></td></tr></table></figure></p>
<h3 id="获取类定义"><a href="#获取类定义" class="headerlink" title="获取类定义"></a>获取类定义</h3><p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br></pre></td></tr></table></figure></p>
<p><code>objc_getClassList</code>函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。<br>下面代码演示了该函数的用法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numClasses;</span><br><span class="line">Class * classes = <span class="literal">NULL</span>;</span><br><span class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">    numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"number of classes: %d"</span>, numClasses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">        Class cls = classes[i];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"class name: %s"</span>, class_getName(cls));</span><br><span class="line">    &#125;</span><br><span class="line">    free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取类定义的方法有三个：<code>objc_lookUpClass</code>, <code>objc_getClass</code>和<code>objc_getRequiredClass</code>。如果类在运行时未注册，则<code>objc_lookUpClass</code>会返回nil，而<code>objc_getClass</code>会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而<code>objc_getRequiredClass</code>函数的操作与<code>objc_getClass</code>相同，只不过如果没有找到类，则会杀死进程。</p>
<p><code>objc_getMetaClass</code>函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在这一章中我们介绍了Runtime运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>1、用分类给NSObject添加一个实例方法（例如<code>- (void)dm_instanceMethod</code>），用类调用的方式调用该方法(<code>[NSObject dm_instanceMethod]</code>)会发生什么？<br>答案：正常调用</p>
<p>回答要点：<br>1、类即对象<br>2、NSObject的isa指向metaClass，即NSObject是metaClass的实例，即NSObject 是一个类对象<br>3、metaClass继承自NSObject</p>
<p>NSObject类对象 调用了从NSObject继承下来的dm_instanceMethod方法</p>
<blockquote>
<p>结论：<br>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
</blockquote>
<p>验证代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">DM</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dm_instanceMethod</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Father</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)getSex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以通过<code>[NSObject dm_instanceMethod]</code>调用，也可以通过其子类<code>[Father dm_instanceMethod]</code>调用<br>而Father中的方法只能通过Father的实例来调用<code>[[Father new] getSex]</code>,不可以通过<code>[Father getSex]</code>调用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a><br><a href="https://developer.apple.com/documentation/objectivec/objective_c_runtime" target="_blank" rel="noopener">Objective-C Runtime</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/runtime/" rel="tag"># runtime</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/04/03/搭建可在不同电脑写作和同步的Hexo博客/" rel="next" title="搭建可在不同电脑写作和同步的Hexo博客">
                <i class="fa fa-chevron-left"></i> 搭建可在不同电脑写作和同步的Hexo博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/08/shell基本语法/" rel="prev" title="shell基本语法">
                shell基本语法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="Leoliu" />
            
              <p class="site-author-name" itemprop="name">Leoliu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/leoliuyt" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:leoliuyt@sina.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/u/0/113639913270953856300" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/p/1005053266784037/home" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象数据结构"><span class="nav-number">1.</span> <span class="nav-text">类与对象数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">1.1.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Meta-Class（元类）"><span class="nav-number">1.2.</span> <span class="nav-text">Meta-Class（元类）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-object与id"><span class="nav-number">1.3.</span> <span class="nav-text">objc_object与id</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类与对象的操作函数"><span class="nav-number">2.</span> <span class="nav-text">类与对象的操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类相关操作函数"><span class="nav-number">2.1.</span> <span class="nav-text">类相关操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类名-name"><span class="nav-number">2.1.1.</span> <span class="nav-text">类名(name)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#父类-super-class-和元类-meta-class"><span class="nav-number">2.1.2.</span> <span class="nav-text">父类(super_class)和元类(meta-class)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例变量大小-instance-size"><span class="nav-number">2.1.3.</span> <span class="nav-text">实例变量大小(instance_size)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量-ivars-及属性"><span class="nav-number">2.1.4.</span> <span class="nav-text">成员变量(ivars)及属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法-methodLists"><span class="nav-number">2.1.5.</span> <span class="nav-text">方法(methodLists)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#协议-objc-protocol-list"><span class="nav-number">2.1.6.</span> <span class="nav-text">协议(objc_protocol_list)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本-version"><span class="nav-number">2.1.7.</span> <span class="nav-text">版本(version)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它"><span class="nav-number">2.1.8.</span> <span class="nav-text">其它</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例"><span class="nav-number">2.1.9.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态创建类和对象"><span class="nav-number">2.2.</span> <span class="nav-text">动态创建类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态创建类"><span class="nav-number">2.2.1.</span> <span class="nav-text">动态创建类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态创建对象"><span class="nav-number">2.2.2.</span> <span class="nav-text">动态创建对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例操作函数"><span class="nav-number">2.3.</span> <span class="nav-text">实例操作函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取类定义"><span class="nav-number">2.4.</span> <span class="nav-text">获取类定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QA"><span class="nav-number">4.</span> <span class="nav-text">QA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">5.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leoliu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
